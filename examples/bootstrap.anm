# What I'm trying to do here is set up a reasonable base environment without
# polluting the top-level environment (i.e. global definitions bad!). I
# interchangably call this environment the bootstrap environment, since it
# defines a lot of what might be considered the core of Anemone

# I've made a concession to readability by defining `__anemone-bsquote`. This
# abides by the vendor-specific naming conventions I've established, so there
# shouldn't be a clash when ported to other implementations. However, since it's
# only used once, in principle it could be inlined.



# Quote all passed expressions and combine them into a sequence block.
# It's just
#     $def (__anemone-bsquote _ _ code) `($__sequence__ ,@code)
# but I don't have quasiquote available yet.
$__defineHere__ __anemone-bsquote: $__lambda__ (env loc code): __sexpr-intro__:
  @__cons__ (__sexpr-intro__: __sym-intro__ "__operate__")
  @__cons__ (__sexpr-intro__: __sym-intro__ "__sequence__")
  code





# Of course, the base environment we are defining is bound in the top-level so that it can be accessed by later code at all.
# Since environments are (append-only) mutated, this statement only creates and binds the environment, but it is still mostly empty.
# TODO update the name of this environment
# TODO define this in the 
$__defineHere__ __anemone-bs:
  @__upd-name__: __name-intro__ (__sym-intro__ "value") (__sym-intro__ "__anemone-bs")
  __new-emptyEnv!__()

# I'll need access to the top level and bootstrap environments to suck in the
# bindings I need from top-level from within the local environment.
__define__ __anemone-bs (__sym-intro__ "value") (__sym-intro__ "__top__"):
  @__upd-name__: __name-intro__ (__sym-intro__ "value") (__sym-intro__ "__top__")
  $($__lambda__ (env loc sexpr) env)

# This will also require putting in __defineHere__ and __lookup__.
# These two will also need __sym-intro__ so I can lift strings into symbols
# (instead of a partial function to descontruct a symbol from an sexpr).
__define__ __anemone-bs (__sym-intro__ "value") (__sym-intro__ "__defineHere__") __defineHere__
__define__ __anemone-bs (__sym-intro__ "value") (__sym-intro__ "__lookup__") __lookup__
__define__ __anemone-bs (__sym-intro__ "value") (__sym-intro__ "__sym-intro__") __sym-intro__

# I also need __sequence__ available because __anemone-bsquote uses it
__define__ __anemone-bs (__sym-intro__ "value") (__sym-intro__ "__sequence__") __sequence__



# The key to not polluting the top-level environment is to immediately begin evaluation inside a non-top-level environment.
# I have chosen to evaluate in a new environment so that I can make local definitions while defining the bootstrap.
# However, that new environment is also a child of the bootstrap, so definitions exproted to the bootstrap can be immediately used here.
__eval__ (__new-env!__ __anemone-bs): $__anemone-bsquote:
  
  # The first thing to do is ensure we can define things in other environments, and espeically the bootstrap environment.
  # I'm also already tired of writing dunders, so let's fix that.
  $__defineHere__ def __defineHere__ # uses the `__defineHere__` that we inserted into the bootstrap env
  $def defIn: __lookup__ __top__ (__sym-intro__ "value") (__sym-intro__ "__define__")
  $def bsEnv: __lookup__ __top__ (__sym-intro__ "value") (__sym-intro__ "__anemone-bs")

  # We'll also quickly want to construct and deconstruct lists, so let's pull that in as well.
  $def list: __lookup__ __top__ (__sym-intro__ "value") (__sym-intro__ "__list__")
  $def uncons: __lookup__ __top__ (__sym-intro__ "value") (__sym-intro__ "__uncons__")

  # A handful of classic helpers drawn from functional programming wouldn't go awry.
  # And by helpers, I guess I mean we also need λ itself.
  $def fn: __lookup__ __top__ (__sym-intro__ "value") (__sym-intro__ "__lambda__")
  $def const: $fn (x _ign) x
  $def map!: $fn (f!): $__sequence__:
    # the bang here is because we expect `f` to have side effects (technically it's expected impure)
    # since we call `f`, the map function has to 
    # a map that performs side effects is likely not interested in the actual mapped list, so we don't bother accumulating it
    $def loop!: $fn (xs₀): uncons xs₀:
      const ()
      $fn (x xs): $__sequence__:
        f! x
        loop! xs

  # And now we need a primitive import procedure to import our primitives.
  # All this does is move symbols from the top-level environment to the boostrap environment.
  $def _suck: $fn (str): $__sequence__:
    $def valNs: __sym-intro__ "value"
    $def sym: __sym-intro__ str
    defIn bsEnv valNs sym: __lookup__ __top__ valNs sym
  # And now we finally have the machinery to import things _en-masse_, so let's do!
  # Note that since __list__ isn't defined here yet, I don't yet have access to zexpr's square-bracket list syntax.
  map! _suck: $list
    # core features
    "__lambda__" "__eval__" "__force__"
    # sequential programming
    # skip "__sequence__"
    # skip "__defineHere__"
    # booleans
    "__true__" "__false__"
    "__cond__"
    "__equal__"
    # arithmetic
    "__add__" "__sub__"
    # lists
    "__list__" "__cons__" "__uncons__"
    # sexprs
    "__sexpr-intro__" "__sexpr-elim__"
    # skip "__sym-intro__"
    "__sym-elim__"
    # types
    "__typeof__"
    "__type-elim__"
    "__tycon-nil__" "__tycon-int__"
    # environments
    "__new-env!__" "__new-emptyEnv!__"
    # skip "__lookup__"
    "__define__"
    # metadata
    "__name-intro__" "__name-elim__"
    "__upd-name__" "__upd-loc__"

  # It is at this point that we have made a copy of the top-level environment in the bootstrap environment.
  # The only difference is that this copy has a child that defines a few extra functions (and will define a few more later).
  # The names of these helpers are reserved, and cannot be defined in the bootstrap environment (because that would craete shadowing).
  # However, they can be bound in other children of the bootstrap.
  # Our intention is for the bootstrap to be frozen after its creation, and the only way to extend the bootstrap environment will be to create new children of it.
  # Therefore, we can use as many names as we want in this local environment without risking a name conflict in code that uses the bootstrap environment.


  # This is ehre for testing only
  __lambda__

# This is ehre for testing only
__eval__ __anemone-bs: $__anemone-bsquote:
  __define__ $($__lambda__ (env loc exprs) env) (__sym-intro__ "value") (__sym-intro__ "bar") 1
